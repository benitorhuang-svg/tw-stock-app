---
/**
 * Heatmap Component (Treemap Version)
 *
 * Implements a Volume-Weighted Treemap.
 * - Size (Area) = Volume
 * - Color = Price Change
 */
interface StockData {
    symbol: string;
    name: string;
    price: number;
    change: number;
    changePercent: number;
    volume: number;
    [key: string]: any;
}

interface Props {
    stocks?: StockData[]; // Optional array of stock data
}
import { getStocksWithPrices } from '../utils/stockDataService';

// 1. Fetch Data or Use Props
const { stocks: propStocks } = Astro.props;

let targetStocks: StockData[] = [];
if (propStocks) {
    targetStocks = propStocks;
} else {
    // Cast the result roughly or assume it matches
    const raw = await getStocksWithPrices();
    targetStocks = raw as unknown as StockData[];
}

// Take top 60 stocks by volume (Too many small blocks make it unreadable)
const topStocks = targetStocks
    .filter(s => s.price > 0 && s.volume > 0)
    .sort((a, b) => b.volume - a.volume)
    .slice(0, 60);

// 2. Treemap Logic (Binary Partition)
// More robust for filling 100% space without gaps

type Rect = { x: number; y: number; w: number; h: number };
type Node = { value: number; data: StockData; rect?: Rect };

function layoutBinary(nodes: Node[], rect: Rect) {
    if (nodes.length === 0) return;

    if (nodes.length === 1) {
        nodes[0].rect = rect;
        return;
    }

    const totalValue = nodes.reduce((sum, n) => sum + n.value, 0);
    const halfValue = totalValue / 2;

    // Find pivot index to split approx in half
    let currentSum = 0;
    let mid = 0;
    for (let i = 0; i < nodes.length; i++) {
        currentSum += nodes[i].value;
        if (currentSum >= halfValue) {
            mid = i;
            break;
        }
    }

    // Adjust partition point to be at least 1 and leave at least 1
    if (mid >= nodes.length - 1 && mid > 0) mid = nodes.length - 2;

    // Split
    const leftNodes = nodes.slice(0, mid + 1);
    const rightNodes = nodes.slice(mid + 1);

    const leftValue = leftNodes.reduce((sum, n) => sum + n.value, 0);
    const leftRatio = leftValue / totalValue;

    // Determine split direction based on aspect ratio of container
    // If wider than tall, split vertically (left/right)
    if (rect.w >= rect.h) {
        const leftW = rect.w * leftRatio;
        const leftRect = { x: rect.x, y: rect.y, w: leftW, h: rect.h };
        const rightRect = { x: rect.x + leftW, y: rect.y, w: rect.w - leftW, h: rect.h };
        layoutBinary(leftNodes, leftRect);
        layoutBinary(rightNodes, rightRect);
    } else {
        // Taller, split horizontally (top/bottom)
        const topH = rect.h * leftRatio;
        const topRect = { x: rect.x, y: rect.y, w: rect.w, h: topH };
        const bottomRect = { x: rect.x, y: rect.y + topH, w: rect.w, h: rect.h - topH };
        layoutBinary(leftNodes, topRect);
        layoutBinary(rightNodes, bottomRect);
    }
}

function computeLayout(data: StockData[]) {
    if (data.length === 0) return [];

    // Explicitly define type to include optional 'rect'
    const nodes: Node[] = data.map(s => ({ value: s.volume, data: s }));

    layoutBinary(nodes, { x: 0, y: 0, w: 100, h: 100 });
    return nodes;
}

const treemapData = computeLayout(topStocks);
---

<div class="heatmap-container reveal-grid">
    <div class="heatmap-header">
        <h3>üî• Â∏ÇÂ†¥ÁÜ±ÂäõÂúñ (Volume Treemap)</h3>
        <p>ÂçÄÂ°äÂ§ßÂ∞è‰ª£Ë°®‰∫§ÊòìÈáè (Volume)ÔºåÈ°èËâ≤‰ª£Ë°®Êº≤Ë∑åÂπÖ„ÄÇ</p>
    </div>

    <div class="treemap-viewport">
        {
            treemapData.map(node => {
                const stock = node.data;
                const pct = stock.changePercent;
                const r = node.rect!;

                let colorClass = 'neutral';
                if (pct > 5) colorClass = 'gain-high';
                else if (pct > 2) colorClass = 'gain-mid';
                else if (pct > 0) colorClass = 'gain-low';
                else if (pct < -5) colorClass = 'loss-high';
                else if (pct < -2) colorClass = 'loss-mid';
                else if (pct < 0) colorClass = 'loss-low';

                // Check if block is large enough to show text
                const showText = r.w > 4 && r.h > 4;
                const showDetail = r.w > 8 && r.h > 8;

                return (
                    <a
                        href={`/stocks/${stock.symbol}/`}
                        class={`treemap-item ${colorClass}`}
                        style={`left: ${r.x}%; top: ${r.y}%; width: ${r.w}%; height: ${r.h}%;`}
                        title={`${stock.name} (${stock.symbol})
Êº≤Ë∑å: ${pct}%
Êàê‰∫§Èáè: ${stock.volume.toLocaleString()}`}
                    >
                        {showText && (
                            <div class="content">
                                <span class="symbol">{stock.symbol}</span>
                                {showDetail && <span class="name">{stock.name}</span>}
                                <span class="pct">{pct}%</span>
                            </div>
                        )}
                    </a>
                );
            })
        }
    </div>
</div>

<style>
    .heatmap-container {
        background: var(--c-bg-glass);
        border: 1px solid var(--c-border);
        border-radius: 16px;
        padding: 24px;
        backdrop-filter: var(--glass-blur);
        display: flex;
        flex-direction: column;
        height: 500px; /* Fixed height for viewport percentage calc */
    }

    .heatmap-header {
        margin-bottom: 16px;
        flex-shrink: 0;
    }

    .heatmap-header h3 {
        font-size: 1.2rem;
        font-weight: 700;
        margin-bottom: 4px;
        color: var(--c-text-primary);
    }

    .heatmap-header p {
        font-size: 0.9rem;
        color: var(--c-text-secondary);
    }

    .treemap-viewport {
        position: relative;
        flex: 1;
        width: 100%;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        overflow: hidden;
    }

    .treemap-item {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        text-decoration: none;
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        overflow: hidden;
        transition:
            transform 0.2s,
            z-index 0.2s;
    }

    .treemap-item:hover {
        z-index: 10;
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        border-color: #fff;
    }

    .content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        line-height: 1.2;
        padding: 2px;
        width: 100%;
        overflow: hidden;
    }

    .symbol {
        font-weight: 800;
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(10px, 1.2vw, 24px); /* Responsive font capping */
    }

    .name {
        font-size: clamp(9px, 0.9vw, 14px);
        white-space: nowrap;
        opacity: 0.9;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 90%;
    }

    .pct {
        font-size: clamp(9px, 0.9vw, 16px);
        font-weight: 700;
        margin-top: 2px;
    }

    /* Colors */
    .treemap-item.gain-high {
        background: #10b981;
    }
    .treemap-item.gain-mid {
        background: #059669;
    }
    .treemap-item.gain-low {
        background: #047857;
    }

    .treemap-item.loss-high {
        background: #ef4444;
    }
    .treemap-item.loss-mid {
        background: #dc2626;
    }
    .treemap-item.loss-low {
        background: #b91c1c;
    }

    .treemap-item.neutral {
        background: #64748b;
    }
</style>
