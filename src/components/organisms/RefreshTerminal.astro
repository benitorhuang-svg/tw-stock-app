---
/**
 * RefreshTerminal.astro - Global refresh data handler and UI
 */
---

<!-- Refresh Terminal Overlay (Global) -->
<div
    id="refresh-overlay"
    class="hidden fixed inset-0 bg-base-deep/95 backdrop-blur-xl z-[100] flex-col flex items-center justify-center p-6"
>
    <div
        class="w-full max-w-3xl bg-surface border border-border/50 rounded-2xl shadow-[0_0_80px_rgba(0,0,0,0.8)] overflow-hidden flex flex-col relative"
    >
        <div class="absolute inset-0 bg-glow-radial opacity-10 pointer-events-none"></div>

        <!-- Terminal Header -->
        <div
            class="bg-base-deep px-5 py-3 border-b border-border/50 flex items-center justify-between relative z-10"
        >
            <div class="flex items-center gap-3">
                <div class="flex gap-1.5">
                    <div class="w-3 h-3 rounded-full bg-red-500/20 border border-red-500/40"></div>
                    <div class="w-3 h-3 rounded-full bg-yellow-500/20 border border-yellow-500/40">
                    </div>
                    <div class="w-3 h-3 rounded-full bg-accent/20 border border-accent/40"></div>
                </div>
                <span
                    class="text-[10px] font-mono font-black text-text-muted tracking-[0.2em] flex items-center gap-2"
                >
                    CORE_DATA_SYNCHRONIZER_V2
                </span>
                <div
                    id="refresh-eta-container"
                    class="flex items-center gap-1.5 ml-4 opacity-0 transition-opacity duration-500 translate-x-3 no-display group"
                >
                    <span
                        class="text-[9px] font-mono font-bold text-accent/80 tracking-widest uppercase"
                        >Estimated Completion:</span
                    >
                    <span
                        id="refresh-eta"
                        class="text-[10px] font-mono font-black text-accent bg-accent/10 border border-accent/20 px-2 py-0.5 rounded shadow-[0_0_10px_rgba(var(--accent-rgb),0.2)]"
                        >--:--</span
                    >
                </div>
            </div>
            <button
                id="close-refresh"
                class="hidden hover:bg-red-500/20 text-text-muted hover:text-red-400 px-3 py-1 rounded-lg transition-colors text-[10px] font-black border border-border/50 hover:border-red-500/30"
                >âœ• é—œé–‰è¦–çª—</button
            >
        </div>

        <!-- Graphical Stage Progress -->
        <div class="p-6 bg-base mt-2 relative z-10">
            <div class="flex justify-between relative">
                <!-- Connecting Line -->
                <div class="absolute top-1/2 left-0 w-full h-[2px] bg-white/5 -translate-y-1/2 z-0">
                </div>
                <div
                    id="stage-progress-line"
                    class="absolute top-1/2 left-0 w-0 h-[2px] bg-accent shadow-[0_0_10px_rgba(var(--accent-rgb),0.5)] -translate-y-1/2 z-0 transition-all duration-700"
                >
                </div>

                <!-- Stages -->
                {
                    [
                        { step: 1, label: 'æ¸…å–®æ›´æ–°', icon: 'ðŸ“‹' },
                        { step: 2, label: 'æ•¸æ“šåŒæ­¥', icon: 'ðŸ”„' },
                        { step: 3, label: 'å¿«ç…§å»ºç½®', icon: 'ðŸ“¸' },
                        { step: 4, label: 'ç´¢å¼•å„ªåŒ–', icon: 'âš¡' },
                        { step: 5, label: 'åŒæ­¥å®Œæˆ', icon: 'âœ…' },
                    ].map(s => (
                        <div
                            class="flex flex-col items-center gap-3 relative z-10 stage-item"
                            data-step={s.step}
                            id={`stage-step-${s.step}`}
                        >
                            <div class="w-10 h-10 rounded-xl bg-surface border border-border/50 flex items-center justify-center text-lg transition-all duration-500 stage-icon grayscale opacity-40 shadow-inner">
                                {s.icon}
                            </div>
                            <div class="flex flex-col items-center">
                                <span class="text-[9px] font-mono text-white/20 font-bold uppercase tracking-tighter">
                                    Step {s.step}
                                </span>
                                <span class="text-[11px] font-black text-white/30 transition-colors stage-label">
                                    {s.label}
                                </span>
                            </div>
                        </div>
                    ))
                }
            </div>
        </div>

        <!-- Terminal Content -->
        <div class="p-4 bg-black/60 relative z-10">
            <div
                id="refresh-terminal"
                class="h-64 overflow-y-auto text-[11px] text-accent/80 font-mono leading-relaxed custom-scrollbar whitespace-pre-wrap p-4 border border-white/5 rounded-lg bg-black/40 shadow-inner"
            >
            </div>
        </div>
    </div>
</div>

<script>
    // Global Refresh Data Handler - MUST be bound on page load for View Transitions
    document.addEventListener('astro:page-load', () => {
        const refreshBtn = document.getElementById('refresh-data-btn') as HTMLButtonElement | null;
        const mobileRefreshBtn = document.getElementById(
            'mobile-refresh-data-btn'
        ) as HTMLButtonElement | null;
        const refreshOverlay = document.getElementById('refresh-overlay');
        const refreshTerminal = document.getElementById('refresh-terminal');
        const closeRefresh = document.getElementById('close-refresh');

        if (refreshOverlay && refreshTerminal && closeRefresh) {
            const startRefresh = async () => {
                if (!confirm('å³å°‡åŸ·è¡Œè³‡æ–™åº«è³‡æ–™æ›´æ–°ï¼Œå°‡é¡¯ç¤ºçµ‚ç«¯æ©Ÿå³æ™‚é€²åº¦ç•«é¢ï¼Œæ˜¯å¦ç¹¼çºŒï¼Ÿ'))
                    return;

                if (refreshBtn) refreshBtn.disabled = true;
                if (mobileRefreshBtn) mobileRefreshBtn.disabled = true;
                refreshOverlay.classList.remove('hidden');
                closeRefresh.classList.add('hidden');
                refreshTerminal.textContent = '>> æ­£åœ¨å»ºç«‹é€£ç·š...\n';

                const timeToSec = (str: string) => {
                    const parts = str.split(':');
                    if (parts.length === 2) return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                    return 0;
                };

                const etaEl = document.getElementById('refresh-eta')!;
                const etaContainer = document.getElementById('refresh-eta-container')!;
                let etaSeconds = 600;
                let etaTimerId: any = null;

                const renderETA = () => {
                    const m = Math.floor(etaSeconds / 60);
                    const s = etaSeconds % 60;
                    etaEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                };

                etaTimerId = setInterval(() => {
                    if (etaSeconds > 0) {
                        etaSeconds--;
                        renderETA();
                    }
                }, 1000);

                const calibrateETA = (newSeconds: number) => {
                    if (Math.abs(etaSeconds - newSeconds) > 15) {
                        etaSeconds = newSeconds;
                        renderETA();
                    }
                };

                const forceETA = (newSeconds: number) => {
                    etaSeconds = newSeconds;
                    renderETA();
                };

                etaContainer.classList.remove('opacity-0', 'translate-x-3');
                renderETA();

                const updateStage = (step: number) => {
                    const line = document.getElementById('stage-progress-line');
                    if (line) line.style.width = `${(step - 1) * 25}%`;

                    document.querySelectorAll('.stage-item').forEach(el => {
                        const s = parseInt((el as HTMLElement).dataset.step || '0');
                        const icon = el.querySelector('.stage-icon');
                        const label = el.querySelector('.stage-label');

                        if (s < step) {
                            icon?.classList.remove(
                                'grayscale',
                                'opacity-40',
                                'border-border/50',
                                'bg-surface'
                            );
                            icon?.classList.add('border-accent/40', 'bg-accent/10', 'text-accent');
                            label?.classList.remove('text-white/30');
                            label?.classList.add('text-accent');
                        } else if (s === step) {
                            icon?.classList.remove(
                                'grayscale',
                                'opacity-40',
                                'border-border/50',
                                'bg-surface'
                            );
                            icon?.classList.add('border-accent', 'bg-accent/20');
                            label?.classList.remove('text-white/30');
                            label?.classList.add('text-white', 'font-black');
                        } else {
                            icon?.classList.add(
                                'grayscale',
                                'opacity-40',
                                'border-border/50',
                                'bg-surface'
                            );
                            icon?.classList.remove('border-accent', 'bg-accent/20', 'text-accent');
                            label?.classList.add('text-white/30');
                            label?.classList.remove('text-white', 'font-black', 'text-accent');
                        }
                    });
                };
                updateStage(1);

                try {
                    const res = await fetch('/api/db/refresh', { method: 'POST' });
                    if (!res.body) throw new Error('ä¼ºæœå™¨æœªè¿”å›žå¯è®€å–çš„ä¸²æµ(ReadableStream)ã€‚');

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let currentText = '';
                    const triggeredStages = new Set<number>();

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });

                        for (const char of chunk) {
                            if (char === '\r') {
                                const lastNewline = currentText.lastIndexOf('\n');
                                if (lastNewline !== -1) {
                                    currentText = currentText.substring(0, lastNewline + 1);
                                } else {
                                    currentText = '';
                                }
                            } else {
                                currentText += char;
                            }
                        }
                        refreshTerminal.textContent = currentText;
                        refreshTerminal.scrollTop = refreshTerminal.scrollHeight;

                        if (currentText.includes('é è¨ˆå‰©é¤˜:')) {
                            const lines = currentText.split('\n');
                            const lastLine = lines[lines.length - 1];
                            const match = lastLine.match(/é è¨ˆå‰©é¤˜: ([^\|\n]+)/);
                            if (match) {
                                const yahooSec = timeToSec(match[1].trim());
                                calibrateETA(yahooSec + 90);
                            }
                        }

                        const checkStage = (marker: string, step: number, eta?: number) => {
                            if (!triggeredStages.has(step) && currentText.includes(marker)) {
                                triggeredStages.add(step);
                                updateStage(step);
                                if (eta !== undefined) forceETA(eta);
                            }
                        };
                        checkStage('[1/4]', 1);
                        checkStage('[2/4]', 2);
                        checkStage('[3/4]', 3, 60);
                        checkStage('[4/4]', 4, 30);
                        checkStage('[å®Œæˆ]', 5, 0);
                    }
                } catch (err) {
                    console.error(err);
                    refreshTerminal.textContent += `\n[ä¸­æ–·] ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: ${(err as Error).message}\n`;
                } finally {
                    if (etaTimerId) clearInterval(etaTimerId);
                    if (refreshBtn) refreshBtn.disabled = false;
                    if (mobileRefreshBtn) mobileRefreshBtn.disabled = false;
                    closeRefresh.classList.remove('hidden');
                    refreshTerminal.scrollTop = refreshTerminal.scrollHeight;
                }
            };

            if (refreshBtn) {
                refreshBtn.removeEventListener('click', startRefresh);
                refreshBtn.addEventListener('click', startRefresh);
            }

            if (mobileRefreshBtn) {
                mobileRefreshBtn.removeEventListener('click', startRefresh);
                mobileRefreshBtn.addEventListener('click', startRefresh);
            }

            const reloadPage = () => window.location.reload();
            closeRefresh.removeEventListener('click', reloadPage);
            closeRefresh.addEventListener('click', reloadPage);
        }
    });
</script>
