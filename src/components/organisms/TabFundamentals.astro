---
import { getQuarterlyReports, getMonthlyRevenue, getEPSGrowth } from '../../data/financials';
import { dbService } from '../../lib/db/sqlite-service';
import type {
    MarginRecord,
    HealthBadge,
    ValuationHistoryRecord,
    PriceHistoryRecord,
} from '../../types/stock';
import ValuationRiverChart from '../molecules/ValuationRiverChart.astro';
import RevenueMomentumChart from '../molecules/RevenueMomentumChart.astro';
import FinancialHealthMatrix from '../molecules/FinancialHealthMatrix.astro';

interface ValuationRecord {
    date: string;
    pe: number;
    pb: number;
    dividend_yield: number;
}

interface RevenueRecord {
    year: number;
    month: number;
    revenue: number;
    revenueYoY: number;
    revenueMoM: number;
    symbol: string;
    accumulated: number;
    accumulatedYoY: number;
}

interface Props {
    symbol: string;
    pe: number;
    pb: number;
    yield_: number;
    roe: number;
    eps: number;
    priceData?: PriceHistoryRecord[];
}

const { symbol, pe, pb, yield_, roe, eps, priceData = [] } = Astro.props;

const quarters = getQuarterlyReports(symbol);
const monthlyRev = getMonthlyRevenue(symbol);

const epsGrowth = getEPSGrowth(symbol);

// üîç Fetch real valuation history from SQL
let valHistory: ValuationRecord[] = [];
try {
    valHistory = dbService
        .queryAll<ValuationRecord>(
            'SELECT date, pe, pb, dividend_yield FROM valuation_history WHERE symbol = ? ORDER BY date DESC LIMIT 250',
            [symbol]
        )
        .reverse();
} catch (e) {
    console.error('ValRiver fetch error:', e);
}

// Revenue bars (generate 12 months if we don't have enough)
const revBars: RevenueRecord[] =
    monthlyRev.length > 0
        ? monthlyRev.slice(0, 12)
        : Array.from({ length: 12 }, (_, i) => ({
              year: 2024,
              month: 12 - i,
              revenue: 200000 + Math.random() * 100000,
              revenueYoY: (Math.random() - 0.3) * 40,
              revenueMoM: 0,
              symbol,
              accumulated: 0,
              accumulatedYoY: 0,
          }));

const maxRev = Math.max(...revBars.map(r => r.revenue), 1);
const hasRealValuation = valHistory.length > 0 && priceData && priceData.length > 0;

const mergedData: ValuationHistoryRecord[] = hasRealValuation
    ? valHistory
          .map(vh => {
              const p = priceData.find(pd => pd.Date === vh.date);
              if (!p) return null;
              return {
                  date: vh.date,
                  pe: vh.pe || 0,
                  pb: vh.pb || 0,
                  close: p.Close,
                  eps_proxy: p.Close / (vh.pe || 1),
              };
          })
          .filter((d): d is ValuationHistoryRecord => d !== null && d.pe > 0)
    : [];

const peLevels =
    mergedData.length > 0
        ? (() => {
              const pes = mergedData.map(d => d.pe);
              const min = Math.min(...pes);
              const max = Math.max(...pes);
              const step = (max - min) / 4;
              return [min, min + step, min + step * 2, min + step * 3, max];
          })()
        : [10, 15, 20, 25, 30];

const hasAcceleration =
    revBars.length >= 3 &&
    revBars[0].revenueYoY > revBars[1].revenueYoY &&
    revBars[1].revenueYoY > revBars[2].revenueYoY;

// Triple margins data from quarterly reports
const marginData: MarginRecord[] =
    quarters.length > 0
        ? quarters.slice(0, 4).reverse()
        : [
              { grossMargin: 55, operatingMargin: 42, netMargin: 36, year: 2024, quarter: 1 },
              { grossMargin: 56, operatingMargin: 45, netMargin: 37, year: 2024, quarter: 2 },
              { grossMargin: 59, operatingMargin: 49, netMargin: 43, year: 2024, quarter: 3 },
              { grossMargin: 60, operatingMargin: 50, netMargin: 45, year: 2024, quarter: 4 },
          ];

// Check triple-up (‰∏âÁéá‰∏âÂçá)
const tripleUp =
    marginData.length >= 2 &&
    (() => {
        const last = marginData[marginData.length - 1];
        const prev = marginData[marginData.length - 2];
        if (!last || !prev) return false;
        return (
            last.grossMargin > prev.grossMargin &&
            last.operatingMargin > prev.operatingMargin &&
            last.netMargin > prev.netMargin
        );
    })();

// Margin sparkline points
const marginPoints = (key: keyof MarginRecord) => {
    const data = marginData.map(d => Number(d[key]) || 0);
    if (data.length === 0) return '';
    const max = Math.max(...data, 1);
    const min = Math.min(...data, 0);
    const range = max - min || 1;
    return data
        .map((v: number, i: number) => {
            const x = (i / Math.max(data.length - 1, 1)) * 180 + 10;
            const y = 55 - ((v - min) / range) * 45;
            return `${x},${y}`;
        })
        .join(' ');
};

// Health badges
const healthBadges: HealthBadge[] = [
    {
        label: 'P/E',
        value: pe > 0 ? pe.toFixed(1) : '‚Äî',
        status: pe > 0 && pe < 15 ? 'good' : pe > 30 ? 'warn' : 'normal',
    },
    {
        label: 'P/B',
        value: pb > 0 ? pb.toFixed(2) : '‚Äî',
        status: pb > 0 && pb < 2 ? 'good' : pb > 5 ? 'warn' : 'normal',
    },
    {
        label: 'ROE',
        value: roe > 0 ? `${roe.toFixed(1)}%` : '‚Äî',
        status: roe >= 15 ? 'good' : roe < 8 && roe > 0 ? 'warn' : 'normal',
    },
    {
        label: 'ÊÆñÂà©Áéá',
        value: yield_ > 0 ? `${yield_.toFixed(2)}%` : '‚Äî',
        status: yield_ >= 4 ? 'good' : yield_ < 2 && yield_ > 0 ? 'warn' : 'normal',
    },
    { label: 'EPS', value: eps > 0 ? eps.toFixed(2) : '‚Äî', status: eps > 5 ? 'good' : 'normal' },
    {
        label: 'EPSÊàêÈï∑',
        value: epsGrowth !== null ? `${epsGrowth.toFixed(1)}%` : '‚Äî',
        status:
            epsGrowth !== null && epsGrowth > 10
                ? 'good'
                : epsGrowth !== null && epsGrowth < 0
                  ? 'warn'
                  : 'normal',
    },
];
---

<div class="space-y-6">
    <!-- Valuation River Chart Placeholder -->
    <ValuationRiverChart
        pe={pe}
        hasRealValuation={hasRealValuation}
        peLevels={peLevels}
        mergedData={mergedData}
    />

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <!-- Revenue Momentum -->
        <RevenueMomentumChart hasAcceleration={hasAcceleration} revBars={revBars} maxRev={maxRev} />

        <!-- Financial Health Matrix -->
        <FinancialHealthMatrix
            tripleUp={tripleUp}
            marginPoints={marginPoints}
            marginData={marginData}
            healthBadges={healthBadges}
        />
    </div>
</div>
