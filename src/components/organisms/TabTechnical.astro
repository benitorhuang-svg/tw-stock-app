---
/**
 * TabTechnical.astro — Technical Analysis Tab (004-tab-technical)
 * K-line chart, MACD, KDJ, RSI sub-indicators with floating toolbar
 * Now uses real price data when available via priceData prop
 */

interface PriceRecord {
    Date: string;
    Open: number;
    High: number;
    Low: number;
    Close: number;
    Volume: number;
}

interface Props {
    symbol: string;
    price: number;
    change: number;
    priceData?: PriceRecord[];
}

const { symbol, price, change, priceData } = Astro.props;

const timeframes = ['15M', '60M', '1D', '1W', '1M'];
const overlays = ['均線 (MAs)', '波浪 (Wave)', '撐壓線 (S/R)'];
const subIndicators = ['MACD', 'KDJ', 'RSI'];

// Use real price data or fallback to simulation
const hasRealData = priceData && priceData.length > 0;
const displayCount = 60;

const candles = hasRealData
    ? priceData.slice(-displayCount).map(r => ({
          o: r.Open,
          c: r.Close,
          h: r.High,
          l: r.Low,
          vol: r.Volume,
          bull: r.Close >= r.Open,
          date: r.Date,
      }))
    : (() => {
          const baseP = price > 0 ? price : 100;
          return Array.from({ length: 30 }, (_, i) => {
              const drift = (i - 15) * 0.3 + (Math.random() - 0.5) * 5;
              const o = baseP + drift + (Math.random() - 0.5) * 3;
              const c = o + (Math.random() - 0.5) * 4;
              const h = Math.max(o, c) + Math.random() * 2;
              const l = Math.min(o, c) - Math.random() * 2;
              const vol = Math.floor(Math.random() * 30000) + 5000;
              return { o: +o.toFixed(2), c: +c.toFixed(2), h: +h.toFixed(2), l: +l.toFixed(2), vol, bull: c >= o, date: '' };
          });
      })();

const priceMax = Math.max(...candles.map(c => c.h));
const priceMin = Math.min(...candles.map(c => c.l));
const priceRange = priceMax - priceMin || 1;
const volMax = Math.max(...candles.map(c => c.vol), 1);

// SVG chart dimensions
const chartW = 600;
const chartH = 280;
const barW = (chartW / candles.length) * 0.6;
const gap = chartW / candles.length;

// Price to Y coordinate
const pToY = (p: number) => ((priceMax - p) / priceRange) * (chartH * 0.75) + 10;
// Volume bar height
const vToH = (v: number) => (v / volMax) * (chartH * 0.2);

// Moving average (simple 5-period)
const ma5Points = candles
    .map((_, i) => {
        if (i < 4) return null;
        const avg = candles.slice(i - 4, i + 1).reduce((s, c) => s + c.c, 0) / 5;
        return { x: i * gap + gap / 2, y: pToY(avg) };
    })
    .filter(Boolean);
const ma5Path = ma5Points.map((p, i) => `${i === 0 ? 'M' : 'L'}${p!.x},${p!.y}`).join(' ');

// MA20 line
const ma20Points = candles
    .map((_, i) => {
        if (i < 19) return null;
        const avg = candles.slice(i - 19, i + 1).reduce((s, c) => s + c.c, 0) / 20;
        return { x: i * gap + gap / 2, y: pToY(avg) };
    })
    .filter(Boolean);
const ma20Path = ma20Points.map((p, i) => `${i === 0 ? 'M' : 'L'}${p!.x},${p!.y}`).join(' ');

// MACD calculation from real close prices (EMA12 - EMA26)
function calcEMA(data: number[], period: number): number[] {
    const k = 2 / (period + 1);
    const ema: number[] = [data[0]];
    for (let i = 1; i < data.length; i++) {
        ema.push(data[i] * k + ema[i - 1] * (1 - k));
    }
    return ema;
}

const closes = candles.map(c => c.c);
const ema12 = calcEMA(closes, 12);
const ema26 = calcEMA(closes, 26);
const macdData = candles.map((_, i) => {
    const dif = ema12[i] - ema26[i];
    return { dif, dea: 0, hist: 0 };
});
// Calculate DEA (signal line = EMA9 of DIF)
const difValues = macdData.map(d => d.dif);
const deaValues = calcEMA(difValues, 9);
for (let i = 0; i < macdData.length; i++) {
    macdData[i].dea = deaValues[i];
    macdData[i].hist = macdData[i].dif - macdData[i].dea;
}
const macdMax = Math.max(
    ...macdData.map(d => Math.max(Math.abs(d.dif), Math.abs(d.dea), Math.abs(d.hist))),
    0.1
);

const showNoData = price <= 0;
---

<div class="relative h-[calc(100dvh-280px)] min-h-[500px] bg-[#050914] rounded-xl overflow-hidden">
    <!-- Floating Toolbar -->
    <div class="absolute top-4 left-4 z-40 flex items-center gap-2">
        <!-- Timeframe Pills -->
        <div
            class="flex items-center gap-1 px-3 py-1.5 rounded-full bg-surface/70 backdrop-blur-md border border-white/[0.08]"
        >
            {
                timeframes.map((tf, i) => (
                    <button
                        class:list={[
                            'px-2.5 py-1 rounded-full text-[10px] font-mono font-bold transition-all',
                            i === 2
                                ? 'bg-accent/20 text-accent'
                                : 'text-text-muted hover:text-text-secondary',
                        ]}
                    >
                        {tf}
                    </button>
                ))
            }
        </div>
        <!-- Overlay Checkboxes -->
        <div
            class="flex items-center gap-1 px-3 py-1.5 rounded-full bg-surface/70 backdrop-blur-md border border-white/[0.08]"
        >
            {
                overlays.map((ov, i) => (
                    <label class="flex items-center gap-1 px-2 py-1 rounded-full text-[10px] font-mono cursor-pointer hover:bg-white/[0.05] transition-colors">
                        <input type="checkbox" class="w-3 h-3 accent-accent" checked={i === 0} />
                        <span class="text-text-muted">{ov}</span>
                    </label>
                ))
            }
        </div>
    </div>

    <!-- Sub-indicator toggles (top-right) -->
    <div
        class="absolute top-4 right-4 z-40 flex items-center gap-1 px-3 py-1.5 rounded-full bg-surface/70 backdrop-blur-md border border-white/[0.08]"
    >
        {
            subIndicators.map((ind, i) => (
                <button
                    class:list={[
                        'px-2.5 py-1 rounded-full text-[10px] font-mono font-bold transition-all',
                        i === 0
                            ? 'bg-accent/20 text-accent'
                            : 'text-text-muted hover:text-text-secondary',
                    ]}
                >
                    {ind}
                </button>
            ))
        }
    </div>

    <!-- Price labels (left axis) -->
    <div
        class="absolute left-2 top-12 bottom-[140px] flex flex-col justify-between text-[9px] font-mono text-text-muted z-10"
    >
        <span>{priceMax.toFixed(1)}</span>
        <span>{((priceMax + priceMin) / 2).toFixed(1)}</span>
        <span>{priceMin.toFixed(1)}</span>
    </div>

    <!-- Main Chart Canvas -->
    <div class="pt-14 px-10 h-[calc(100%-120px)]">
        <svg viewBox={`0 0 ${chartW} ${chartH}`} class="w-full h-full" preserveAspectRatio="none">
            <!-- Grid lines -->
            {
                [0.25, 0.5, 0.75].map(pct => (
                    <line
                        x1="0"
                        y1={chartH * pct}
                        x2={chartW}
                        y2={chartH * pct}
                        stroke="hsl(0,0%,100%,0.04)"
                        stroke-width="0.5"
                    />
                ))
            }

            <!-- Volume bars (bottom 20%) -->
            {
                candles.map((c, i) => {
                    const x = i * gap + (gap - barW) / 2;
                    const h = vToH(c.vol);
                    return (
                        <rect
                            x={x}
                            y={chartH - h}
                            width={barW}
                            height={h}
                            fill={c.bull ? 'hsl(142,71%,45%,0.15)' : 'hsl(346,77%,50%,0.15)'}
                            rx="1"
                        />
                    );
                })
            }

            <!-- Candlesticks -->
            {
                candles.map((c, i) => {
                    const x = i * gap + gap / 2;
                    const bodyTop = pToY(Math.max(c.o, c.c));
                    const bodyBot = pToY(Math.min(c.o, c.c));
                    const bodyH = Math.max(bodyBot - bodyTop, 1);
                    const wickTop = pToY(c.h);
                    const wickBot = pToY(c.l);
                    const color = c.bull ? '#22c55e' : '#ef4444';
                    return (
                        <g>
                            <line
                                x1={x}
                                y1={wickTop}
                                x2={x}
                                y2={wickBot}
                                stroke={color}
                                stroke-width="1"
                            />
                            <rect
                                x={x - barW / 2}
                                y={bodyTop}
                                width={barW}
                                height={bodyH}
                                fill={color}
                                rx="0.5"
                            />
                        </g>
                    );
                })
            }

            <!-- MA5 line -->
            <path d={ma5Path} fill="none" stroke="hsl(48,100%,60%)" stroke-width="1.2" opacity="0.7"
            ></path>
            <!-- MA20 line -->
            {ma20Path && (
                <path d={ma20Path} fill="none" stroke="hsl(280,80%,65%)" stroke-width="1.2" opacity="0.5"
                ></path>
            )}
        </svg>
    </div>

    <!-- MACD Sub-chart -->
    <div class="h-[120px] px-10 border-t border-white/[0.05]">
        <div class="flex items-center gap-2 py-1.5 px-2">
            <span class="text-[9px] font-mono font-bold text-text-muted tracking-wider">MACD</span>
            <span class="text-[9px] font-mono text-accent">DIF</span>
            <span class="text-[9px] font-mono text-warning">DEA</span>
        </div>
        <svg viewBox={`0 0 ${chartW} 80`} class="w-full h-[80px]" preserveAspectRatio="none">
            <!-- Zero line -->
            <line x1="0" y1="40" x2={chartW} y2="40" stroke="hsl(0,0%,100%,0.06)" stroke-width="0.5"
            ></line>

            <!-- Histogram bars -->
            {
                macdData.map((d, i) => {
                    const x = i * gap + (gap - barW) / 2;
                    const h = (Math.abs(d.hist) / macdMax) * 35;
                    const y = d.hist >= 0 ? 40 - h : 40;
                    return (
                        <rect
                            x={x}
                            y={y}
                            width={barW}
                            height={h}
                            fill={d.hist >= 0 ? 'hsl(346,77%,50%,0.5)' : 'hsl(142,71%,45%,0.5)'}
                            rx="0.5"
                        />
                    );
                })
            }

            <!-- DIF line -->
            <polyline
                points={macdData
                    .map((d, i) => `${i * gap + gap / 2},${40 - (d.dif / macdMax) * 35}`)
                    .join(' ')}
                fill="none"
                stroke="hsl(217,91%,60%)"
                stroke-width="1"
                opacity="0.8"></polyline>
            <!-- DEA line -->
            <polyline
                points={macdData
                    .map((d, i) => `${i * gap + gap / 2},${40 - (d.dea / macdMax) * 35}`)
                    .join(' ')}
                fill="none"
                stroke="hsl(38,92%,50%)"
                stroke-width="1"
                opacity="0.8"></polyline>
        </svg>
    </div>

    <!-- No data overlay -->
    {
        showNoData && (
            <div class="absolute inset-0 flex flex-col items-center justify-center bg-[#050914]/90 z-50">
                <p class="text-sm font-mono text-text-muted">Initializing Charting Engine...</p>
            </div>
        )
    }
</div>
