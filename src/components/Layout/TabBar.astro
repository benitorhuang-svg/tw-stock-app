---
/**
 * å¤šæ¨™ç±¤é æ¢å…ƒä»¶ - Phase 1å¯¦ç¾
 * 
 * åŠŸèƒ½ï¼š
 * - å¤šæ¨™ç±¤æ‰“é–‹å’Œç®¡ç†
 * - æ‹–æ‹½é‡æ’
 * - å¿«é€Ÿåˆ‡æ› (Ctrl+Tab)
 * - å³éµèœå–® (é—œé–‰ã€è¤‡è£½éˆæ¥ç­‰)
 * 
 * @module TabBar
 * @version 1.0.0
 */

interface Tab {
  id: string;
  label: string;
  href: string;
  icon: string;
  closeable?: boolean;
}

interface Props {
  currentPath: string;
}

const { currentPath } = Astro.props;

// é˜²æ­¢ Astro ç·¨è­¯æ™‚å ±éŒ¯ï¼Œå®šç¾©é»˜èªæ¨™ç±¤é 
const initialTabs: Tab[] = [];
---

<div class="tab-bar" id="tab-bar" role="tablist">
  <div class="tabs-container" id="tabs-container">
    <!-- æ¨™ç±¤é å‹•æ…‹ç”Ÿæˆ -->
  </div>
  
  <!-- æ¨™ç±¤é èœå–®ï¼ˆå³éµï¼‰ -->
  <div class="tab-context-menu" id="tab-context-menu">
    <button class="context-item" data-action="close">é—œé–‰</button>
    <button class="context-item" data-action="close-others">é—œé–‰å…¶ä»–</button>
    <button class="context-item" data-action="close-right">é—œé–‰å³å´</button>
    <div class="context-divider"></div>
    <button class="context-item" data-action="copy-link">è¤‡è£½éˆæ¥</button>
  </div>
</div>

<style>
  .tab-bar {
    display: flex;
    align-items: center;
    height: 44px;
    background: var(--c-bg-glass);
    border-bottom: 1px solid var(--c-border);
    padding: 0 12px;
    gap: 4px;
    overflow-x: auto;
    overflow-y: hidden;
    user-select: none;
  }

  .tab-bar::-webkit-scrollbar {
    height: 4px;
  }

  .tab-bar::-webkit-scrollbar-track {
    background: transparent;
  }

  .tab-bar::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  }

  .tab-bar::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .tabs-container {
    display: flex;
    gap: 4px;
    flex-wrap: nowrap;
    min-width: 100%;
  }

  /* Tab Item */
  .tab-item {
    display: flex;
    align-items: center;
    gap: 8px;
    height: 32px;
    padding: 0 12px;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 6px;
    color: var(--c-text-secondary);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s var(--ease-out);
    white-space: nowrap;
    position: relative;
    flex-shrink: 0;
    border: 1px solid var(--c-border);
  }

  .tab-item:hover {
    background: rgba(255, 255, 255, 0.05);
    color: var(--c-text-primary);
  }

  .tab-item.active {
    background: rgba(var(--c-accent-rgb), 0.1);
    color: var(--c-accent);
    border-color: rgba(var(--c-accent-rgb), 0.3);
    box-shadow: 0 0 10px rgba(var(--c-accent-rgb), 0.15);
  }

  .tab-icon {
    font-size: 14px;
    min-width: 16px;
  }

  .tab-label {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tab-close {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
    background: transparent;
    border: none;
    color: inherit;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
    margin-left: 4px;
  }

  .tab-close:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  /* Context Menu */
  .tab-context-menu {
    position: fixed;
    background: var(--c-bg-glass);
    border: 1px solid var(--c-border);
    border-radius: 6px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    display: none;
    z-index: 1000;
    min-width: 160px;
    padding: 4px;
  }

  .tab-context-menu.visible {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .context-item {
    display: flex;
    align-items: center;
    height: 32px;
    padding: 0 12px;
    background: transparent;
    border: none;
    color: var(--c-text-secondary);
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
    text-align: left;
  }

  .context-item:hover {
    background: rgba(255, 255, 255, 0.05);
    color: var(--c-accent);
  }

  .context-divider {
    height: 1px;
    background: var(--c-border);
    margin: 2px 0;
  }

  /* éŸ¿æ‡‰å¼ */
  @media (max-width: 768px) {
    .tab-bar {
      height: 40px;
      padding: 0 8px;
    }

    .tab-item {
      height: 28px;
      padding: 0 8px;
      font-size: 11px;
    }

    .tab-label {
      max-width: 80px;
    }
  }
</style>

<script>
  /**
   * Tab Management System
   * Handles opening, closing, and switching tabs
   */
  
  interface TabItem {
    id: string;
    label: string;
    href: string;
    icon: string;
    closeable: boolean;
  }

  class TabManager {
    private tabs: Map<string, TabItem> = new Map();
    private activeTabId: string = '';
    private container: HTMLElement | null = null;
    private contextMenu: HTMLElement | null = null;
    private contextTargetId: string = '';

    constructor() {
      this.container = document.getElementById('tabs-container');
      this.contextMenu = document.getElementById('tab-context-menu');
      this.initializeFromStorage();
      this.attachEventListeners();
      this.render();
    }

    private initializeFromStorage(): void {
      const saved = localStorage.getItem('tw-tabs');
      const savedActive = localStorage.getItem('tw-active-tab');
      
      if (saved) {
        try {
          const tabs = JSON.parse(saved);
          tabs.forEach((tab: TabItem) => {
            this.tabs.set(tab.id, tab);
          });
          if (savedActive && this.tabs.has(savedActive)) {
            this.activeTabId = savedActive;
          } else {
            this.activeTabId = this.tabs.keys().next().value || '';
          }
        } catch (e) {
          console.warn('Failed to restore tabs:', e);
        }
      }

      // Create initial tab if none exist
      if (this.tabs.size === 0) {
        this.addTab({
          id: 'home',
          label: 'é¦–é ',
          href: '/',
          icon: 'ğŸ ',
          closeable: false
        });
      }
    }

    public addTab(tab: TabItem): void {
      this.tabs.set(tab.id, tab);
      this.activeTabId = tab.id;
      this.save();
      this.render();
    }

    public closeTab(id: string): void {
      if (this.tabs.get(id)?.closeable === false) return;
      
      this.tabs.delete(id);
      
      if (this.activeTabId === id) {
        this.activeTabId = Array.from(this.tabs.keys())[0] || '';
      }
      
      this.save();
      this.render();
    }

    public switchTab(id: string): void {
      if (this.tabs.has(id)) {
        this.activeTabId = id;
        const tab = this.tabs.get(id);
        if (tab) {
          window.location.href = tab.href;
        }
      }
    }

    public closeOtherTabs(keepId: string): void {
      const toDelete = Array.from(this.tabs.keys()).filter(id => 
        id !== keepId && this.tabs.get(id)?.closeable !== false
      );
      
      toDelete.forEach(id => this.tabs.delete(id));
      
      if (!this.tabs.has(this.activeTabId)) {
        this.activeTabId = keepId;
      }
      
      this.save();
      this.render();
    }

    public closeRightTabs(fromId: string): void {
      const keys = Array.from(this.tabs.keys());
      const index = keys.indexOf(fromId);
      
      if (index >= 0) {
        const toDelete = keys.slice(index + 1).filter(id => 
          this.tabs.get(id)?.closeable !== false
        );
        toDelete.forEach(id => this.tabs.delete(id));
      }
      
      this.save();
      this.render();
    }

    private save(): void {
      localStorage.setItem('tw-tabs', JSON.stringify(Array.from(this.tabs.values())));
      localStorage.setItem('tw-active-tab', this.activeTabId);
    }

    private render(): void {
      if (!this.container) return;
      
      this.container.innerHTML = '';
      
      this.tabs.forEach((tab, id) => {
        const tabEl = document.createElement('button');
        tabEl.className = `tab-item ${id === this.activeTabId ? 'active' : ''}`;
        tabEl.setAttribute('data-tab-id', id);
        tabEl.setAttribute('role', 'tab');
        
        tabEl.innerHTML = `
          <span class="tab-icon">${tab.icon}</span>
          <span class="tab-label">${tab.label}</span>
          ${tab.closeable ? '<button class="tab-close">Ã—</button>' : ''}
        `;
        
        // é»æ“Šåˆ‡æ›
        tabEl.addEventListener('click', (e) => {
          if ((e.target as HTMLElement).classList.contains('tab-close')) {
            this.closeTab(id);
          } else {
            this.switchTab(id);
          }
        });
        
        // å³éµèœå–®
        tabEl.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          this.showContextMenu(e as MouseEvent, id);
        });
        
        // æ‹–æ‹½é‡æ’
        tabEl.draggable = true;
        tabEl.addEventListener('dragstart', (e) => {
          (e.dataTransfer as DataTransfer).effectAllowed = 'move';
          (e.dataTransfer as DataTransfer).setData('text/plain', id);
        });
        
        tabEl.addEventListener('dragover', (e) => {
          e.preventDefault();
          (e.dataTransfer as DataTransfer).dropEffect = 'move';
        });
        
        tabEl.addEventListener('drop', (e) => {
          e.preventDefault();
          const draggedId = (e.dataTransfer as DataTransfer).getData('text/plain');
          if (draggedId !== id) {
            this.reorderTabs(draggedId, id);
          }
        });
        
        this.container!.appendChild(tabEl);
      });
    }

    private reorderTabs(fromId: string, toId: string): void {
      const entries = Array.from(this.tabs.entries());
      const fromIndex = entries.findIndex(([id]) => id === fromId);
      const toIndex = entries.findIndex(([id]) => id === toId);
      
      if (fromIndex >= 0 && toIndex >= 0) {
        const [movedEntry] = entries.splice(fromIndex, 1);
        entries.splice(toIndex, 0, movedEntry);
        
        this.tabs = new Map(entries);
        this.save();
        this.render();
      }
    }

    private showContextMenu(event: MouseEvent, tabId: string): void {
      this.contextTargetId = tabId;
      
      if (!this.contextMenu) return;
      
      this.contextMenu.classList.add('visible');
      this.contextMenu.style.left = event.clientX + 'px';
      this.contextMenu.style.top = event.clientY + 'px';
    }

    private attachEventListeners(): void {
      // éš±è—å³éµèœå–®
      document.addEventListener('click', () => {
        this.contextMenu?.classList.remove('visible');
      });
      
      // å³éµèœå–®å‹•ä½œ
      this.contextMenu?.querySelectorAll('.context-item').forEach(item => {
        item.addEventListener('click', (e) => {
          const action = (e.target as HTMLElement).getAttribute('data-action');
          
          switch (action) {
            case 'close':
              this.closeTab(this.contextTargetId);
              break;
            case 'close-others':
              this.closeOtherTabs(this.contextTargetId);
              break;
            case 'close-right':
              this.closeRightTabs(this.contextTargetId);
              break;
            case 'copy-link':
              const tab = this.tabs.get(this.contextTargetId);
              if (tab) {
                navigator.clipboard.writeText(window.location.origin + tab.href);
              }
              break;
          }
          
          this.contextMenu?.classList.remove('visible');
        });
      });
      
      // éµç›¤å¿«æ·éµ
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Tab') {
          e.preventDefault();
          const keys = Array.from(this.tabs.keys());
          const currentIndex = keys.indexOf(this.activeTabId);
          
          if (e.shiftKey) {
            // Ctrl+Shift+Tab: ä¸Šä¸€å€‹æ¨™ç±¤
            const nextIndex = (currentIndex - 1 + keys.length) % keys.length;
            this.switchTab(keys[nextIndex]);
          } else {
            // Ctrl+Tab: ä¸‹ä¸€å€‹æ¨™ç±¤
            const nextIndex = (currentIndex + 1) % keys.length;
            this.switchTab(keys[nextIndex]);
          }
        }
      });
    }
  }

  // åˆå§‹åŒ–æ¨™ç±¤ç®¡ç†å™¨
  window.addEventListener('DOMContentLoaded', () => {
    (window as any).tabManager = new TabManager();
  });

  // æš´éœ²å…¨å±€æ–¹æ³•ä¾›å…¶ä»–çµ„ä»¶ä½¿ç”¨
  (window as any).openTab = function(label: string, href: string, icon: string = 'ğŸ“„') {
    const id = 'tab-' + Date.now();
    (window as any).tabManager?.addTab({
      id,
      label,
      href,
      icon,
      closeable: true
    });
  };
</script>
