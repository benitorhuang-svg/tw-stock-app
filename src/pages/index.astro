---
import MainTerminal from '../layouts/MainTerminal.astro';
import DashboardController from '../components/organisms/DashboardController.svelte';
import SentimentTrendModal from '../components/organisms/SentimentTrendModal.astro';

interface DashboardStock {
    symbol: string;
    name: string;
    market: string;
    price: number;
    change: number;
    changePercent: number;
    volume: number;
    high: number;
    low: number;
    open: number;
    close: number;
    date?: string;
    pe: number;
    pb: number;
    yield: number;
    roe: number;
    eps: number;
    revenueYoY: number;
    grossMargin: number;
    operatingMargin: number;
    netMargin: number;
    foreignStreak: number;
    trustStreak: number;
    dealerStreak: number;
    sector: string;
}

let gainers: DashboardStock[] = [];
let losers: DashboardStock[] = [];
let topVolume: DashboardStock[] = [];

let upCount = 0;
let downCount = 0;
let flatCount = 0;
let dataDate = '';
let totalVolume = 0;
let avgChange = 0;
let breadthTimeline: any[] = [];
let distribution: any = null;

try {
    // Fast path: direct SQL aggregation (SSR mode with DB available)
    const { dbService } = await import('../lib/db/sqlite-service');

    const summary = dbService.queryOne<{
        total: number;
        up: number;
        down: number;
        flat: number;
        total_vol: number;
        avg_chg: number;
        latest_date: string;
        p9: number;
        p6_9: number;
        p3_6: number;
        p0_3: number;
        zero: number;
        m0_3: number;
        m3_6: number;
        m6_9: number;
        m9: number;
    }>(`
        SELECT
            COUNT(*) as total,
            SUM(CASE WHEN change_pct > 0 THEN 1 ELSE 0 END) as up,
            SUM(CASE WHEN change_pct < 0 THEN 1 ELSE 0 END) as down,
            SUM(CASE WHEN change_pct = 0 AND close > 0 THEN 1 ELSE 0 END) as flat,
            SUM(volume) as total_vol,
            AVG(change_pct) as avg_chg,
            MAX(date) as latest_date,
            SUM(CASE WHEN change_pct >= 9 THEN 1 ELSE 0 END) as p9,
            SUM(CASE WHEN change_pct >= 6 AND change_pct < 9 THEN 1 ELSE 0 END) as p6_9,
            SUM(CASE WHEN change_pct >= 3 AND change_pct < 6 THEN 1 ELSE 0 END) as p3_6,
            SUM(CASE WHEN change_pct > 0 AND change_pct < 3 THEN 1 ELSE 0 END) as p0_3,
            SUM(CASE WHEN change_pct = 0 THEN 1 ELSE 0 END) as zero,
            SUM(CASE WHEN change_pct > -3 AND change_pct < 0 THEN 1 ELSE 0 END) as m0_3,
            SUM(CASE WHEN change_pct > -6 AND change_pct <= -3 THEN 1 ELSE 0 END) as m3_6,
            SUM(CASE WHEN change_pct > -9 AND change_pct <= -6 THEN 1 ELSE 0 END) as m6_9,
            SUM(CASE WHEN change_pct <= -9 THEN 1 ELSE 0 END) as m9
        FROM latest_prices WHERE close > 0
    `);

    if (summary) {
        upCount = summary.up;
        downCount = summary.down;
        flatCount = summary.flat;
        totalVolume = summary.total_vol;
        avgChange = summary.avg_chg;
        dataDate = summary.latest_date || '';
        distribution = {
            p9: summary.p9,
            p6_9: summary.p6_9,
            p3_6: summary.p3_6,
            p0_3: summary.p0_3,
            zero: summary.zero,
            m0_3: summary.m0_3,
            m3_6: summary.m3_6,
            m6_9: summary.m6_9,
            m9: summary.m9,
        };
    }

    const mapRow = (r: any): DashboardStock => ({
        symbol: r.symbol,
        name: r.name || r.symbol,
        market: r.market || 'TWSE',
        price: r.close,
        change: r.change || 0,
        changePercent: r.change_pct,
        volume: r.volume,
        high: r.high || 0,
        low: r.low || 0,
        open: r.open || 0,
        close: r.close,
        date: r.date,
        pe: r.pe || 0,
        pb: r.pb || 0,
        yield: r.yield || 0,
        roe: 0,
        eps: r.eps || 0,
        revenueYoY: r.revenue_yoy || 0,
        grossMargin: r.gross_margin || 0,
        operatingMargin: r.operating_margin || 0,
        netMargin: r.net_margin || 0,
        foreignStreak: 0,
        trustStreak: 0,
        dealerStreak: 0,
        sector: r.sector || 'other',
    });

    const selectCols = `s.symbol, s.name, s.market, s.sector, lp.close, lp.change, lp.change_pct, lp.volume, lp.high, lp.low, lp.open, lp.date, lp.pe, lp.pb, lp.yield, lp.eps, lp.revenue_yoy, lp.gross_margin, lp.operating_margin, lp.net_margin`;

    gainers = dbService
        .queryAll<any>(
            `SELECT ${selectCols} FROM latest_prices lp JOIN stocks s ON s.symbol = lp.symbol WHERE lp.change_pct > 0 ORDER BY lp.change_pct DESC LIMIT 3000`
        )
        .map(mapRow);

    losers = dbService
        .queryAll<any>(
            `SELECT ${selectCols} FROM latest_prices lp JOIN stocks s ON s.symbol = lp.symbol WHERE lp.change_pct < 0 ORDER BY lp.change_pct ASC LIMIT 3000`
        )
        .map(mapRow);

    topVolume = dbService
        .queryAll<any>(
            `SELECT ${selectCols} FROM latest_prices lp JOIN stocks s ON s.symbol = lp.symbol WHERE lp.volume > 0 ORDER BY lp.volume DESC LIMIT 3000`
        )
        .map(mapRow);

    // Fetch breadth timeline for instant chart rendering
    breadthTimeline = dbService.queryAll<any>(`
        SELECT * FROM (
            SELECT 
                date,
                count(CASE WHEN change_pct > 0 THEN 1 END) as up,
                count(CASE WHEN change_pct < 0 THEN 1 END) as down,
                count(CASE WHEN change_pct = 0 THEN 1 END) as flat
            FROM price_history
            WHERE close > 0
            GROUP BY date
            ORDER BY date DESC
            LIMIT 150
        ) sub
        ORDER BY date ASC
    `);
} catch {
    // Fallback: JSON-based data loading (static build / no DB)
    try {
        const svc = await import('../utils/stockDataService');
        const all = await svc.getStocksWithPrices();
        dataDate = all.find(s => s.date)?.date || '';
        const withPrice = all.filter(s => s.price > 0);
        upCount = withPrice.filter(s => s.changePercent > 0).length;
        downCount = withPrice.filter(s => s.changePercent < 0).length;
        flatCount = withPrice.filter(s => s.changePercent === 0).length;
        totalVolume = withPrice.reduce((sum, s) => sum + s.volume, 0);
        avgChange =
            withPrice.length > 0
                ? withPrice.reduce((sum, s) => sum + s.changePercent, 0) / withPrice.length
                : 0;
        gainers = withPrice
            .filter(s => s.changePercent > 0)
            .sort((a, b) => b.changePercent - a.changePercent)
            .slice(0, 3000) as DashboardStock[];
        losers = withPrice
            .filter(s => s.changePercent < 0)
            .sort((a, b) => a.changePercent - b.changePercent)
            .slice(0, 3000) as DashboardStock[];
        topVolume = [...withPrice]
            .sort((a, b) => b.volume - a.volume)
            .slice(0, 3000) as DashboardStock[];
    } catch (e2) {
        console.error('Dashboard data load error:', e2);
    }
}
---

<MainTerminal title="市場漲幅">
    <div class="space-y-6 relative pb-20">
        <DashboardController
            client:load
            upCount={upCount}
            downCount={downCount}
            flatCount={flatCount}
            totalVolume={totalVolume}
            avgChange={avgChange}
            dataDate={dataDate}
            gainers={gainers}
            losers={losers}
            topVolume={topVolume}
            initialBreadthData={breadthTimeline}
            distribution={distribution}
        />

        <SentimentTrendModal />
    </div>
</MainTerminal>
```
